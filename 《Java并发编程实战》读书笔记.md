[TOC]
## 《Java并发编程实战》读书笔记  
### 第二章、线程安全性  
#### 一种正常的编程方法  
​	首先保证代码可以正确的运行,然后再提高代码的速度(在必要的时候才去做这种优化)。

#### 什么是线程安全性  
​	当多个线程同时访问某个类时,无论在任何条件下,这个类都可以表现出正确的行为,那么这个类就是线程安全的。  

#### 锁的可重入性
​	对于同一个锁,同一个线程可以重复进入这个锁,这就叫做锁的可重入性。  

#### 用锁来保护状态  
> 对于每个包含多个变量的不变形条件,其中涉及的所有变量都需要由同一个锁来保护。**(就是如果一个共享变量在一个地方用锁来保护了,那任何有用到这个共享变量的地方都应该用同一个锁来保护它)。**    

#### 活跃性和性能  
> 要判断同步代码块的合理大小,需要在各种设计需求之间进行权衡,包括安全性(这个需求必须得到满足)、简单性和性能。**通常,在简单性与性能之间存在着制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性(这可能会破坏安全性)。**  
> **一定不要把那些执行时间较长的操作放在同步块!!**  

### 第三章、对象的共享  
#### 可见性    
```java
public class NoVisibility {
    public static long number;
    public static boolean ready;

    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready) {
                Thread.yield();
            }
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```
​	这段代码的运行结果看上去好像必然是输出42。其实不然,也有可能输出0,也有可能一直看不到ready的值。这是因为java编译器的重排序现象造成的。

>
> **重排序:在没有同步的情况下,编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断,几乎无法的出正确的结论。**  
>
> 加锁的含义并不仅仅局限于互斥行为,还包括内存可见性。为了确保所有的线程都能看到共享变量的最新值。

#### Volatile变量  
​	使用volatile关键字可以使变量变的可见。任何线程读取使用volatile修饰的变量都能读到最新值。
​	`但是volatile变量要慎用!!因为它只能控制变量可见性,比同步锁来的更加脆弱。` 

#### 发布和逸出  

​	在发布一个对象的时候要避免this引用在构造函数中逸出。(一般是在构造函数中创建了一个线程并且启动它的时候会使this引用逸出)



#### 线程封闭  

​	**Ad-hoc线程封闭**:维护线程封闭性的职责完全由程序实现来承担。

​	**栈封闭**:变量由线程内部使用或线程局部使用。(局部变量等)

​	**ThreadLocal类**:每个线程都各自的唯一的值。



#### 不变性  

> 不可变对象一定是线程安全的  
>
> 当满足以下条件时，对象才是不可变的:  
>
> - 对象创建以后其状态就不能修改。
> - 对象的所有域是final类型。
> - 对象是正确创建的(在对象的创建期间,this引用没有逸出)。  



#### 安全发布  

> 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布:  
>
> - 在静态初始化函数中初始化一个对象引用。  
> - 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。  
> - 将对象的引用保存到某个正确构造对象的final类型域中。  
> - 将对象的引用保存到一个由锁保护的域中。

> 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为**事实不可变对象**。 

> 对象的发布需求取决于它的可变性:  
>
> - 不可变对象可以通过任意机制来发布。
> - 事实不可变对象必须通过安全方式来发布。  
> - 可变对象必须通过安全方式来发布,并且必须是线程安全的或者由某个锁保护起来。  

### 第四章、对象的组合
#### 设计线程安全的类  
> 在设计线程安全类的过程中,需要包括以下三个基本元素:
>
> - 找出构成对象状态的所有变量
> - 找出约束状态变量的不变性条件  
> - 建立对象状态的并发访问管理策略    

​	要确保类的线程安全性,就要确保它的不变性条件不会在并发访问的情况下被破坏,这需要对其状态进行推断,需要判断类的状态是否始终都是有效的。(满足其约束性,比如一个状态的范围要是0-100之间,那就要保证无论怎么并发访问这个类,他的范围都不会超过这个有效区间)

#### 实例封闭  

> 将数据封装在对象内部,可以将数据的访问限制在对象的方法上,从而更容易确保线程在访问数据时总能持有正确的锁。   

可以将一个线程不安全的类封装在一个类中,然后又内置锁去控制它,这样就可以构成一个线程安全类了。

##### Java监视器模式  

​	把对象的所有可变状态都封装起来,并由对象自己的内置锁来保护,这就是监视器模式。JDK中的Vector和Hashtable都用到了这种模式。

#### 线程安全性的委托  

​	将线程安全性委托给某个线程安全的类。比如某个类只有一个状态是AtomicLong的域,那它肯定就是线程安全的。因为它将线程安全性委托给了AtomicLong来保证。

​	当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时,Java监视器模式是非常有用的。但是如果类中的各个组件都是线程安全的,那就要考虑用另外一些模式。  

> 如果一个类是由多个独立且线程安全的状态变量组成,并且在所有的操作中都不包含无效状态转换,那么可以将线程安全性委托给底层的状态变量。  

#### 在现有的线程安全类中添加功能  

#### 将同步策略文档化   

​	方便以后的人开发维护  



###　第五章、基础构件模块




